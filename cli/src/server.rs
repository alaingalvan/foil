use crate::builder::get_foil_builder_path;
use crate::builder::read_foil_package;
use crate::builder::BuildMode;
use crate::misc::{get_db_url, DATABASE_URL};
use lexiclean::Lexiclean;
use path_slash::PathBufExt;
use std::env;
use std::fs;
use std::process;

fn clean_path_string(p: &std::path::PathBuf) -> String {
    p.clone()
        .lexiclean()
        .to_slash()
        .unwrap()
        .to_string()
        .replace("\\", "/")
}

//=====================================================================================================================
// NPM is somewhat buggy at times, and requires the extension on windows.
#[cfg(windows)]
const FOIL_BACKEND: &'static str = "foil_backend.exe";

#[cfg(not(windows))]
const FOIL_BACKEND: &'static str = "foil_backend";

pub async fn start_server(_build_mode: BuildMode) {
    // üì¶ Resolve Foil package.json from current working directory, attempt to run server from it:
    let cwd = env::current_dir().unwrap_or_default();
    let cwd_package = cwd.join("package.json");
    let cwd_foil_package_res = read_foil_package(&cwd_package);
    if cwd_foil_package_res.is_err() {
        println!("‚ùå Failed to find foil package.json in current working directory, aborting.");
        return;
    }
    let cwd_foil_package = cwd_foil_package_res.unwrap();
    if cwd_foil_package.foil.html.is_empty() {
        println!("‚ùå Foil package.json's 'foil' object must have a valid 'html' member pointing to a JavaScript/TypeScript file with a React element default export.");
        return;
    }
    let html_src = cwd.join(cwd_foil_package.foil.html);
    let mut html_src_str = clean_path_string(&html_src);
    html_src_str = "file:///".to_string() + &html_src_str;

    // ‚öΩ A foil website needs a default path to public files, generally a `static` or `assets` folder:
    let assets_path = if cwd_foil_package.foil.assets.is_empty() {
        cwd.join("assets")
    } else {
        let assets_sanitized = cwd_foil_package.foil.assets[0].replace("*", "");
        cwd.join(assets_sanitized)
    }
    .to_str()
    .unwrap_or_default()
    .replace("\\", "/")
    .replace("//", "/");

    // üåê Spawn child processes for the server:
    let foil_database_url = get_db_url();
    let mut backend_server_child = process::Command::new(&FOIL_BACKEND)
        .current_dir(&cwd)
        .stdin(process::Stdio::null())
        .env_remove("args")
        .env(DATABASE_URL, foil_database_url)
        .arg(&assets_path)
        .spawn()
        .unwrap();

    // üé® The Foil server-side renderer currently exists as a separate process here,
    // we may eventually move this to the server itself where it pipes requests to a child process...
    let mut server_source =
        "// ‚ö†Ô∏è Warning: This file was generated by Foil and doesn't need to be touched.\n"
            .to_string();
    server_source += "import Default from \"";
    server_source += &html_src_str;
    server_source += "\";\n";
    server_source += include_str!("server-renderer.tsx");

    // Due to the idiosyncrasies of Node.js and TypeScript, we must generate and load a renderer file:
    // Also, due to the way node resolves modules, it must exist next to the frontend.
    let server_source_file = cwd_foil_package.name + "-renderer.generated.tsx";
    let server_source_file_abs = cwd.join(&server_source_file);
    let server_source_file_abs_str = clean_path_string(&server_source_file_abs);

    let write_result = fs::write(&server_source_file_abs, server_source);
    if write_result.is_err() {
        println!(
            "‚ùå Failed to write foil renderer.generated.tsx in current working directory, aborting."
        );
        return;
    }

    // Resolve ts-node esm loader:
    let foil_builder_path = get_foil_builder_path();
    let ts_node_abs = foil_builder_path.join("node_modules/ts-node/esm.mjs");
    let mut ts_node_abs_str = clean_path_string(&ts_node_abs);
    ts_node_abs_str = "file:///".to_string() + &ts_node_abs_str;

    let cwd_node_modules = clean_path_string(&cwd.join("node_modules"));
    let builder_node_modules = clean_path_string(&foil_builder_path.join("node_modules"));
    let node_path_str = builder_node_modules + ";" + &cwd_node_modules;

    let mut backend_renderer_child = process::Command::new("node")
        .current_dir(&cwd)
        .env("NODE_PATH", node_path_str)
        .args([
            "--experimental-specifier-resolution=node",
            "--experimental-modules",
            "--experimental-import-meta-resolve",
            "--no-warnings",
            "--loader",
            &ts_node_abs_str,
            &server_source_file_abs_str,
        ])
        .spawn()
        .unwrap();

    backend_renderer_child
        .wait()
        .expect("‚ùå Failed to run Foil Renderer...");
    backend_server_child
        .wait()
        .expect("‚ùå Failed to run Foil Backend...");
}
